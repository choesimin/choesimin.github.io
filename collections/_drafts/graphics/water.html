<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>인터랙티브 물 효과</title>
    <style>
        body {
            background-color: #000;
            color: #fff;
            margin: 0;
            padding: 0;
            font-family: 'Courier New', monospace;
            line-height: 1;
            font-size: 10px;
            font-weight: bold;
            overflow: hidden;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            white-space: pre;
        }
    </style>
</head>
<body>
    <script>
        // 설정
        let width = 120;
        let height = 40;
        let waterLevel = [];
        let targetWaterLevel = [];
        let velocities = [];
        const maxWaterLevel = 0.9; // 최대 물 높이 (화면 높이의 90%)
        const refillRate = 0.005; // 물이 다시 차오르는 속도
        
        // 화면 크기에 따라 캔버스 크기 조정
        function resizeCanvas() {
            const containerWidth = window.innerWidth;
            const containerHeight = window.innerHeight;
            
            const charWidth = 8;  // 픽셀 단위의 예상 문자 너비
            const charHeight = 16; // 픽셀 단위의 예상 문자 높이
            
            width = Math.floor(containerWidth / charWidth);
            height = Math.floor(containerHeight / charHeight);
            
            // 초기화
            initializeWater();
        }
        
        // 물 초기화 - 처음에는 가득 차 있음
        function initializeWater() {
            waterLevel = [];
            targetWaterLevel = [];
            velocities = [];
            
            // 초기 물 높이 설정 (높을수록 물이 많음)
            for (let x = 0; x < width; x++) {
                waterLevel[x] = height * maxWaterLevel; // 90% 채워진 상태
                targetWaterLevel[x] = height * maxWaterLevel; // 목표 높이
                velocities[x] = 0;
            }
        }
        
        // 물 제거 함수
        function removeWater(x, radius, amount) {
            x = Math.floor(x);
            radius = Math.floor(radius);
            
            // 범위 내에서 물 제거
            for (let i = x - radius; i <= x + radius; i++) {
                if (i >= 0 && i < width) {
                    // 중심에서 멀어질수록 영향력 감소
                    const distance = Math.abs(i - x);
                    const factor = 1 - (distance / radius);
                    
                    if (factor > 0) {
                        // 물 제거하면서 파도 생성
                        waterLevel[i] -= amount * factor;
                        velocities[i] -= amount * factor * 0.5;
                        
                        // 물이 없으면 0으로 제한
                        if (waterLevel[i] < 0) {
                            waterLevel[i] = 0;
                        }
                    }
                }
            }
        }
        
        // 물 시뮬레이션 업데이트
        function updateWater() {
            // 파도 전파
            const newWaterLevel = [...waterLevel];
            const newVelocities = [...velocities];
            
            for (let x = 0; x < width; x++) {
                // 좌우 픽셀과의 높이 차이 계산
                let leftDiff = 0;
                let rightDiff = 0;
                
                if (x > 0) leftDiff = waterLevel[x-1] - waterLevel[x];
                if (x < width-1) rightDiff = waterLevel[x+1] - waterLevel[x];
                
                // 속도 업데이트
                newVelocities[x] = velocities[x] * 0.98 + (leftDiff + rightDiff) * 0.1;
                
                // 물 높이 업데이트
                newWaterLevel[x] += newVelocities[x];
                
                // 물이 없으면 0으로 제한
                if (newWaterLevel[x] < 0) newWaterLevel[x] = 0;
                
                // 물 다시 채우기 - 목표 높이보다 낮으면 천천히 증가
                if (newWaterLevel[x] < targetWaterLevel[x]) {
                    newWaterLevel[x] += refillRate;
                    
                    // 갑작스럽게 차오르지 않도록 속도 제한
                    if (newVelocities[x] < 0) {
                        newVelocities[x] *= 0.9;
                    }
                }
            }
            
            // 업데이트된 값 적용
            waterLevel = newWaterLevel;
            velocities = newVelocities;
        }
        
        // 화면 그리기 함수
        function render() {
            // 빈 프레임 생성
            let frame = '';
            
            // 각 행에 대해
            for (let y = 0; y < height; y++) {
                // 각 열에 대해
                for (let x = 0; x < width; x++) {
                    // 물의 높이 확인하여 문자 선택
                    const waterHeight = height - waterLevel[x];
                    
                    if (y === Math.floor(waterHeight)) {
                        // 물 표면 - 속도에 따라 다른 문자 선택
                        const velocity = Math.abs(velocities[x]);
                        
                        if (velocity > 1) {
                            frame += '^';
                        } else if (velocity > 0.5) {
                            frame += '~';
                        } else {
                            frame += '-';
                        }
                    } else if (y > waterHeight) {
                        // 물 속
                        const depth = y - waterHeight;
                        const velocity = Math.abs(velocities[x]);
                        
                        if (velocity > 1) {
                            frame += '≋';
                        } else if (velocity > 0.5) {
                            frame += '≈';
                        } else if (depth < 2) {
                            frame += '~';
                        } else {
                            frame += '≈';
                        }
                    } else {
                        // 물 위 (빈 공간)
                        frame += ' ';
                    }
                }
                frame += '\n';
            }
            
            document.body.textContent = frame;
        }
        
        // 애니메이션 루프
        function animate() {
            updateWater();
            render();
            requestAnimationFrame(animate);
        }
        
        // 마우스 이벤트 핸들러
        function handleInteraction(clientX, clientY) {
            const x = clientX / window.innerWidth * width;
            const y = clientY / window.innerHeight * height;
            
            // 물이 있는 위치를 클릭한 경우에만 물 제거
            const waterHeight = height - waterLevel[Math.floor(x)];
            if (y >= waterHeight) {
                // 클릭한 위치에서 물 제거
                removeWater(x, 10, 5);
            }
        }
        
        // 이벤트 리스너
        document.addEventListener('mousedown', function(e) {
            handleInteraction(e.clientX, e.clientY);
        });
        
        document.addEventListener('mousemove', function(e) {
            if (e.buttons === 1) {  // 마우스 버튼 누른 상태에서 이동
                handleInteraction(e.clientX, e.clientY);
            }
        });
        
        document.addEventListener('touchstart', function(e) {
            e.preventDefault();
            handleInteraction(e.touches[0].clientX, e.touches[0].clientY);
        });
        
        document.addEventListener('touchmove', function(e) {
            e.preventDefault();
            handleInteraction(e.touches[0].clientX, e.touches[0].clientY);
        });
        
        window.addEventListener('resize', resizeCanvas);
        
        // 초기화 및 시작
        resizeCanvas();
        animate();
    </script>
</body>
</html>