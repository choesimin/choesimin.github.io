<!DOCTYPE html>
<html>
<head>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      font-family: monospace;
    }
    
    #canvas {
      white-space: pre;
      color: #fff;
      font-size: 12px;
      line-height: 1;
      user-select: none;
    }
  </style>
</head>
<body>
  <pre id="canvas"></pre>

  <script>
    const canvas = document.getElementById('canvas');
    const WIDTH = 80;
    const HEIGHT = 40;
    
    let time = 0;
    let mouseX = 0;
    let mouseY = 0;
    
    // 초기 프레임 만들기
    let frame = Array(HEIGHT).fill().map(() => Array(WIDTH).fill(' '));
    
    // 마우스 이벤트 추적
    document.addEventListener('mousemove', (e) => {
      mouseX = e.clientX / window.innerWidth;
      mouseY = e.clientY / window.innerHeight;
    });
    
    function getChar(value) {
      const chars = '.,:;i1tfLCG08@';
      const index = Math.floor(value * (chars.length - 1));
      return chars[index];
    }
    
    function animate() {
      time += 0.05;
      
      // 프레임 계산
      for (let y = 0; y < HEIGHT; y++) {
        for (let x = 0; x < WIDTH; x++) {
          const normalizedX = x / WIDTH - 0.5;
          const normalizedY = y / HEIGHT - 0.5;
          
          // 다양한 수학적 패턴 결합
          const distance = Math.sqrt(normalizedX * normalizedX + normalizedY * normalizedY);
          const angle = Math.atan2(normalizedY, normalizedX);
          
          // 마우스 위치에 영향을 받는 패턴들
          const mouseFactor = Math.sin(distance * 10 - time + mouseX * 5) * 0.5 + 0.5;
          const waveFactor = Math.sin(angle * 3 + time) * 0.5 + 0.5;
          const rippleFactor = Math.sin(distance * 15 - time * 2) * 0.5 + 0.5;
          
          // 다양한 패턴을 혼합
          const mixFactor1 = Math.sin(time * 0.5) * 0.5 + 0.5;
          const mixFactor2 = Math.cos(time * 0.3) * 0.5 + 0.5;
          
          // 최종 패턴 계산
          let value = mouseFactor * mixFactor1 + waveFactor * (1 - mixFactor1);
          value = value * mixFactor2 + rippleFactor * (1 - mixFactor2);
          
          // 마우스 거리에 따른 추가 효과
          const mouseDistX = normalizedX - (mouseX - 0.5);
          const mouseDistY = normalizedY - (mouseY - 0.5);
          const mouseDist = Math.sqrt(mouseDistX * mouseDistX + mouseDistY * mouseDistY);
          
          if (mouseDist < 0.2) {
            value = value * 0.5 + Math.sin(mouseDist * 50 - time * 3) * 0.25 + 0.25;
          }
          
          frame[y][x] = getChar(value);
        }
      }
      
      // 프레임 렌더링
      canvas.textContent = frame.map(row => row.join('')).join('\n');
      
      // 다음 프레임
      requestAnimationFrame(animate);
    }
    
    // 색상 애니메이션
    function colorShift() {
      const hue = (time * 10) % 360;
      canvas.style.color = `hsl(${hue}, 100%, 70%)`;
      setTimeout(colorShift, 100);
    }
    
    // 애니메이션 시작
    animate();
    colorShift();
  </script>
</body>
</html>