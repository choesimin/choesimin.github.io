<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  <title>파티클 심장 박동</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      outline: 0;
      user-select: none;
      -webkit-user-select: none;
    }
    
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background-color: #050505;
    }
    
    canvas {
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <script>
    window.onload = function() {
      const canvas = document.createElement('canvas');
      document.body.appendChild(canvas);
      const ctx = canvas.getContext('2d');
      
      // 파티클 속성
      const gridSize = 25;
      let cols, rows;
      let particles = [];
      
      // 심장 박동 관련
      let heartbeatTime = 0;
      const maxHeartbeatInterval = 120; // 기본(느린) 심장 박동 간격 (프레임)
      const minHeartbeatInterval = 30; // 최소(빠른) 심장 박동 간격 (프레임)
      let currentHeartbeatInterval = maxHeartbeatInterval; // 현재 심장 박동 간격
      const heartbeatDuration = 20; // 심장 박동 지속 시간 (프레임)
      let heartbeatStrength = 0; // 현재 심장 박동 강도
      let isHeartbeating = false;
      let waveProgress = 0; // 파동 진행 정도 (0~1)
      
      // 마우스/터치 상태 관련
      let isPressed = false; // 마우스/터치 눌림 상태
      let pressStartTime = 0; // 마우스/터치 시작 시간
      const maxSpeedupTime = 60; // 최대 속도에 도달하는 시간 (프레임)
      const speedCooldownRate = 0.05; // 속도가 원래대로 돌아오는 속도 (프레임당)
      
      // 동일한 기본 색상 사용
      const baseColor = '#800000'; // 진한 붉은색
      
      // 캔버스 리사이즈 함수
      function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // 그리드 점 계산
        cols = Math.floor(canvas.width / gridSize) + 2;
        rows = Math.floor(canvas.height / gridSize) + 2;
        
        createParticles();
      }
      
      // 파티클 생성 함수
      function createParticles() {
        particles = [];
        
        for (let y = 0; y < rows; y++) {
          for (let x = 0; x < cols; x++) {
            const px = x * gridSize;
            const py = y * gridSize;
            
            particles.push({
              x: px,
              y: py,
              originalX: px,
              originalY: py,
              vx: 0,
              vy: 0,
              color: baseColor, // 모든 파티클에 동일한 색상 적용
              baseColor: baseColor,
              size: gridSize * 0.4,
              minSize: 1
            });
          }
        }
      }
      
      // 심장 박동 업데이트 함수
      function updateHeartbeat() {
        // 마우스/터치 상태에 따라 박동 간격 조절
        updateHeartbeatInterval();
        
        heartbeatTime++;
        
        if (heartbeatTime >= currentHeartbeatInterval) {
          // 심장 수축 시작
          isHeartbeating = true;
          heartbeatStrength = 1.0;
          waveProgress = 0; // 파동 시작
          heartbeatTime = 0;
        } else if (isHeartbeating) {
          // 심장 수축 진행 중
          heartbeatStrength -= 1.0 / heartbeatDuration;
          waveProgress += 1.0 / heartbeatDuration; // 파동 진행
          
          if (heartbeatStrength <= 0) {
            isHeartbeating = false;
            heartbeatStrength = 0;
            waveProgress = 1.0; // 파동 완료
          }
        }
      }
      
      // 심장 박동 간격 업데이트 함수
      function updateHeartbeatInterval() {
        if (isPressed) {
          // 마우스/터치 누르고 있을 때 점점 빨라짐
          pressStartTime++;
          
          // 속도 변화율 계산 (0~1 사이)
          const speedupRate = Math.min(1, pressStartTime / maxSpeedupTime);
          
          // 현재 간격 계산 (선형 보간)
          currentHeartbeatInterval = maxHeartbeatInterval - 
            (maxHeartbeatInterval - minHeartbeatInterval) * speedupRate;
        } else {
          // 마우스/터치 놓았을 때 천천히 원래 속도로 돌아감
          if (currentHeartbeatInterval < maxHeartbeatInterval) {
            currentHeartbeatInterval += (maxHeartbeatInterval - minHeartbeatInterval) * speedCooldownRate;
            
            // 최대값 제한
            if (currentHeartbeatInterval > maxHeartbeatInterval) {
              currentHeartbeatInterval = maxHeartbeatInterval;
            }
          }
          
          // 누르기 시작 시간 초기화
          pressStartTime = 0;
        }
      }
      
      // 애니메이션 함수
      function animate() {
        requestAnimationFrame(animate);
        
        // 배경 그리기
        ctx.fillStyle = 'rgba(5, 5, 5, 0.15)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        updateHeartbeat();
        
        // 화면 중앙에서의 거리와 방향 계산 위한 변수
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        
        // 파티클 업데이트 및 그리기
        for (let i = 0; i < particles.length; i++) {
          const p = particles[i];
          
          // 기본 위치로부터의 변위 계산
          let offsetX = 0;
          let offsetY = 0;
          
          // 심장 박동 효과
          if (isHeartbeating) {
            // 화면 중앙에서의 거리 계산
            const dx = p.originalX - centerX;
            const dy = p.originalY - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // 최대 거리 계산 (화면 대각선 길이의 절반)
            const maxDistance = Math.sqrt(canvas.width * canvas.width + canvas.height * canvas.height) / 2;
            
            // 거리 비율 (0: 중앙, 1: 최대 거리)
            const distanceRatio = distance / maxDistance;
            
            // 파동 두께 (0~1 사이, 작을수록 좁은 파동)
            const waveWidth = 0.2;
            
            // 현재 파동이 도달한 거리 비율 (0: 중앙, 1: 최대 거리)
            const waveReachRatio = waveProgress;
            
            // 파동 효과 계산 (파동이 현재 위치를 지나가고 있는지)
            const distanceFromWave = Math.abs(distanceRatio - waveReachRatio);
            
            // 파동 강도 계산 (파동 중앙에 가까울수록 강함)
            let waveStrength = 0;
            if (distanceFromWave < waveWidth) {
              // 파동 내부에 있을 때
              waveStrength = 1 - (distanceFromWave / waveWidth);
              
              // 거리에 따른 감쇠 적용 (멀수록 약해짐)
              waveStrength *= (1 - distanceRatio * 0.3);
              
              // 시간에 따른 감쇠 적용 (시간이 지날수록 약해짐)
              waveStrength *= heartbeatStrength;
            }
            
            if (waveStrength > 0) {
              // 파동 방향 계산 (중앙에서 바깥쪽으로)
              const angle = Math.atan2(dy, dx);
              
              // 파동 강도에 따른 이동 거리
              const pulseStrength = waveStrength * 15; // 이동 거리 증가
              
              // 이동 벡터 계산
              offsetX = Math.cos(angle) * pulseStrength;
              offsetY = Math.sin(angle) * pulseStrength;
              
              // 색상 변화 (더 밝은 빨간색으로)
              const intensity = Math.min(255, 100 + waveStrength * 155);
              p.color = `rgb(${intensity}, ${intensity / 5}, ${intensity / 8})`;
            } else {
              p.color = p.baseColor;
            }
          } else {
            p.color = p.baseColor;
          }
          
          // 위치 업데이트
          p.vx = p.vx * 0.9 + (p.originalX + offsetX - p.x) * 0.1;
          p.vy = p.vy * 0.9 + (p.originalY + offsetY - p.y) * 0.1;
          
          p.x += p.vx;
          p.y += p.vy;
          
          // 사각형 크기 계산
          let size = p.size;
          if (isHeartbeating) {
            // 중앙에서의 거리 계산
            const dx = p.originalX - centerX;
            const dy = p.originalY - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const maxDistance = Math.sqrt(canvas.width * canvas.width + canvas.height * canvas.height) / 2;
            const distanceRatio = distance / maxDistance;
            
            // 파동이 현재 위치에 도달했는지 계산
            const waveReachRatio = waveProgress;
            const distanceFromWave = Math.abs(distanceRatio - waveReachRatio);
            const waveWidth = 0.2;
            
            // 파동에 의한 크기 변화
            if (distanceFromWave < waveWidth) {
              const waveStrength = 1 - (distanceFromWave / waveWidth);
              size += waveStrength * heartbeatStrength * gridSize * 0.4;
            }
          }
          
          // 그리기
          ctx.fillStyle = p.color;
          const safeSize = Math.max(size, 1);
          
          // 사각형 그리기
          ctx.fillRect(p.x - safeSize/2, p.y - safeSize/2, safeSize, safeSize);
        }
        
        // 심장박동 시 화면 전체에 적용되는 펄스 효과
        if (isHeartbeating && heartbeatStrength > 0.5) {
          ctx.fillStyle = `rgba(128, 0, 0, ${heartbeatStrength * 0.1})`;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        // 현재 심장 박동 속도 시각화 (디버깅용, 필요시 주석 해제)
        /*
        const speedRatio = 1 - ((currentHeartbeatInterval - minHeartbeatInterval) / (maxHeartbeatInterval - minHeartbeatInterval));
        ctx.fillStyle = `rgba(255, 255, 255, 0.3)`;
        ctx.fillRect(20, 20, 200 * speedRatio, 10);
        */
      }
      
      // 마우스/터치 이벤트 리스너
      function handleStart() {
        isPressed = true;
      }
      
      function handleEnd() {
        isPressed = false;
      }
      
      // 마우스 이벤트 등록
      canvas.addEventListener('mousedown', handleStart);
      window.addEventListener('mouseup', handleEnd);
      
      // 터치 이벤트 등록
      canvas.addEventListener('touchstart', handleStart);
      window.addEventListener('touchend', handleEnd);
      
      // 초기화 및 애니메이션 시작
      resize();
      window.addEventListener('resize', resize);
      animate();
    };
  </script>
</body>
</html>